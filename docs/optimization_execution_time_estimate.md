# 最適化実行時間の見積もり

## 実行時間に影響する要因

### 1. キャッシュの再構築時間（--force-rebuild-cache使用時）

**期間**: 2018-01-31 ～ 2024-12-31（約7年間）
**リバランス日数**: 約72-84日（月次リバランス）

**見積もり**:
- 1日あたりの特徴量計算: 約30秒〜2分（データ量とCPU性能による）
- 全期間のキャッシュ構築: **約30分〜3時間**
- 並列実行（bt_workers=-1）: CPU数に応じて短縮可能

**注意**: 既存キャッシュがある場合は、該当期間のみ再構築されるため、時間は短縮されます。

### 2. 最適化の実行時間

**試行回数**: 200回（n_trials=200）
**train期間のリバランス日数**: 約60-70日（2018-01-31 ～ 2023-12-31）

**各trialの処理時間**:
- 特徴量取得（キャッシュから）: 数秒
- ポートフォリオ選定（各リバランス日）: 約5-10秒/日
  - **今回の修正により**: entry_scoreの再計算が追加（約+2-5秒/日）
- パフォーマンス計算（24Mホライズン）: 約10-20秒/日

**1 trialあたりの時間**:
- ポートフォリオ選定: 60-70日 × 10-15秒 = **約10-18分**
- パフォーマンス計算: 60-70日 × 15-20秒 = **約15-23分**
- **合計: 約25-40分/trial**

**200 trialの総時間**:
- 逐次実行の場合: 25-40分 × 200 = **約83-133時間（3.5-5.5日）**
- 並列実行（n_jobs=4, bt_workers=4）: **約20-33時間（1-1.4日）**

### 3. 今回の修正による追加時間

**entry_scoreの再計算**:
- 以前: キャッシュから読み込み（ほぼ0秒）
- 修正後: 各trialで再計算（約2-5秒/リバランス日）

**追加時間/trial**:
- 60-70日 × 2-5秒 = **約2-6分/trial**

**200 trialでの追加時間**:
- 逐次実行: 2-6分 × 200 = **約7-20時間**
- 並列実行: **約2-5時間**

## 総実行時間の見積もり

### ケース1: キャッシュ再構築 + 最適化（--force-rebuild-cache）

**並列実行（n_jobs=4, bt_workers=4）の場合**:
- キャッシュ再構築: 30分〜3時間
- 最適化実行: 20-33時間
- entry_score再計算の追加: 2-5時間
- **合計: 約23-41時間（1-1.7日）**

### ケース2: 既存キャッシュを使用（--force-rebuild-cacheなし）

**並列実行（n_jobs=4, bt_workers=4）の場合**:
- キャッシュ読み込み: 数分
- 最適化実行: 20-33時間
- entry_score再計算の追加: 2-5時間
- **合計: 約22-38時間（0.9-1.6日）**

## 時間短縮の方法

### 1. 試行回数を減らす
- `--n-trials 100`: 実行時間が約半分に
- 最初の確認には100回で十分な場合もある

### 2. 並列実行数を増やす
- `--n-jobs 8 --bt-workers 8`: 実行時間がさらに短縮
- CPU数に応じて調整

### 3. キャッシュを事前に構築
- 最適化実行前にキャッシュを構築しておく
- `--force-rebuild-cache`なしで実行可能

### 4. 期間を短縮（テスト用）
- `--start 2020-01-31`: リバランス日数が減り、時間短縮

## 推奨実行方法

### 初回実行（キャッシュ再構築付き）

```powershell
# 時間: 約1-1.7日
python -m omanta_3rd.jobs.optimize_longterm `
  --start 2018-01-31 `
  --end 2024-12-31 `
  --study-type C `
  --n-trials 200 `
  --train-end-date 2023-12-31 `
  --as-of-date 2024-12-31 `
  --horizon-months 24 `
  --lambda-penalty 0.00 `
  --force-rebuild-cache `
  --n-jobs 4 `
  --bt-workers 4
```

### 2回目以降（既存キャッシュ使用）

```powershell
# 時間: 約0.9-1.6日
python -m omanta_3rd.jobs.optimize_longterm `
  --start 2018-01-31 `
  --end 2024-12-31 `
  --study-type C `
  --n-trials 200 `
  --train-end-date 2023-12-31 `
  --as-of-date 2024-12-31 `
  --horizon-months 24 `
  --lambda-penalty 0.00 `
  --n-jobs 4 `
  --bt-workers 4
```

### クイックテスト（試行回数削減）

```powershell
# 時間: 約0.5-0.8日
python -m omanta_3rd.jobs.optimize_longterm `
  --start 2018-01-31 `
  --end 2024-12-31 `
  --study-type C `
  --n-trials 50 `
  --train-end-date 2023-12-31 `
  --as-of-date 2024-12-31 `
  --horizon-months 24 `
  --lambda-penalty 0.00 `
  --force-rebuild-cache `
  --n-jobs 4 `
  --bt-workers 4
```

## 注意事項

1. **実行時間は環境によって大きく異なります**
   - CPU性能、メモリ、ディスクI/O速度に依存
   - 上記の見積もりは参考値です

2. **並列実行の効果**
   - `n_jobs`: Optunaのtrial並列数（通常は2-4が最適）
   - `bt_workers`: 各trial内のバックテスト並列数（リバランス日数に応じて調整）

3. **メモリ使用量**
   - 並列実行数を増やすとメモリ使用量も増加
   - システムリソースに応じて調整が必要

4. **中断と再開**
   - OptunaのstudyはSQLiteに保存されるため、中断しても再開可能
   - `load_if_exists=True`により、既存のtrialを引き継げる

