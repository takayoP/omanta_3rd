# 2023-01-31の両ルート比較結果（詳細分析）

## 重要な発見

### ⚠️ **ポートフォリオが完全に異なる**

| 項目 | optimize側 | compare側 |
|------|-----------|----------|
| **銘柄コード** | [129845, 129600, 128461, 129843, 129844, 128797, 129314, 129301, 128881, 128332, 128816, 128614] | [1661, 512, 1425, 503, 1418, 1304, 1420, 137, 338, 895, 819, 793] |
| **重み** | 不均等（7.94%～8.80%） | 等権重（8.33%） |
| **total_return_pct** | **50.74%** | **24.61%** |
| **topix_return_pct** | 40.55% | 40.55% |
| **excess_return_pct** | **10.19%** | **-15.94%** |
| **年率超過リターン** | **4.22%** | **-6.92%** |

### 原因

**パラメータが異なります。**

#### optimize側（最新の最適化結果）
- **最良パラメータ**（`optimization_result_optimization_longterm_studyC_20260111_154617.json`）:
  - `w_quality`: 0.499
  - `w_value`: 0.113
  - `w_growth`: 0.062
  - `w_record_high`: 0.033
  - `w_size`: 0.384
  - `w_forward_per`: 0.539
  - `roe_min`: **0.139**
  - `bb_weight`: 0.310
  - `rsi_base`: 21.51
  - `rsi_max`: 46.52
  - `bb_z_base`: -3.18
  - `bb_z_max`: -2.20

#### compare側（以前の最適化結果）
- **パラメータ**（`params_operational_24M_lambda0.00_20260111.json`）:
  - `w_quality`: 0.129
  - `w_value`: **0.717**
  - `w_growth`: 0.066
  - `w_record_high`: 0.022
  - `w_size`: 0.065
  - `w_forward_per`: 0.631
  - `roe_min`: **0.002**
  - `bb_weight`: 0.319
  - `rsi_base`: 19.15
  - `rsi_max`: 32.28
  - `bb_z_base`: -1.22
  - `bb_z_max`: -1.81

**主な違い:**
- `w_quality`: 0.499 vs 0.129（約4倍）
- `w_value`: 0.113 vs 0.717（約6倍の違い）
- `w_size`: 0.384 vs 0.065（約6倍）
- `roe_min`: **0.139 vs 0.002**（約70倍）
- `rsi_max`: 46.52 vs 32.28（約1.4倍）
- `bb_z_base`: -3.18 vs -1.22（約2.6倍）

## 結論

### ChatGPTの指摘通り、**ポートフォリオが一致しない**

これは、`test_mean_excess_return_pct`と`avg_annualized_excess_return_pct`の差の原因が、「集約方法の違い」ではなく、「**ポートフォリオ生成の違い（パラメータの違い）**」であることを示しています。

### ただし、これは「バグ」ではなく「比較対象の違い」

- **optimize側**: 最新の最適化で見つかった最良パラメータを使用
- **compare側**: 以前の最適化結果（lambda0.00の結果）を使用

両者は**異なるパラメータ**を使用しているため、ポートフォリオが異なるのは当然です。

## 次のステップ

### 同じパラメータで比較する必要がある

ChatGPTの指摘通り、同じパラメータで比較する必要があります。以下の2つのアプローチが考えられます：

1. **compare側で最新の最適化結果のパラメータを使用**
   - 最新の最適化結果（`optimization_result_optimization_longterm_studyC_20260111_154617.json`）の最良パラメータをパラメータファイルに保存
   - そのパラメータファイルを使用してcompare側を実行

2. **optimize側で以前のパラメータを使用**
   - 以前のパラメータファイル（`params_operational_24M_lambda0.00_20260111.json`）を使用してoptimize側を実行
   - ただし、optimize側は最適化の一部なので、これは実質的には不可能

### 推奨アプローチ

**compare側で最新の最適化結果のパラメータを使用**するのが適切です。これにより：
- 最新の最適化結果に基づいた評価が可能
- `test_mean_excess_return_pct`と`avg_annualized_excess_return_pct`が同じパラメータで計算される

ただし、今回の比較は「異なるパラメータ」を比較していたため、差が大きいのは当然です。

## 重要な発見

今回の比較で明らかになったことは、**同じパラメータで比較する必要がある**ということです。

現在の`test_mean_excess_return_pct`（13.80%）と`avg_annualized_excess_return_pct`（1.49%）の差は、以前の最適化結果（lambda0.00）と最新の最適化結果の違いによる可能性があります。

同じパラメータで比較するためには、最新の最適化結果のパラメータをパラメータファイルに保存し、compare側で使用する必要があります。

