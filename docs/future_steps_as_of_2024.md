# as_of_date=2024での24M評価の設計

## 概要

`as_of_date=2024-12-31`に上げて、24Mのtest年を2022にする場合の設計を整理します。

## 現在の設定

### 現在の状況（`as_of_date=2023-12-31`）

- **`as_of_date`**: 2023-12-31
- **`train_end_date`**: 2022-12-31（固定？）
- **24M test期間**: 2021年（2021-01-29 ～ 2021-12-30、12ヶ月分）
  - `train_max_rb = train_end_date - 24M = 2020-12-31`
  - `test_max_rb = as_of_date - 24M = 2021-12-31`
  - `test_rb = (train_max_rb, test_max_rb] = (2020-12-31, 2021-12-31]`

## 推奨される設計（`as_of_date=2024-12-31`）

### 設計意図

- **開発（λ選定・再最適化）**：`as_of_date=2024-12-31`まで使用（※2025は温存）
- 24Mの検証：rebalanceが**2022年**なら24M満了は**2024年**なので評価可能
- こうすると「2021だけ」の極端さを避けられますし、12本増えて安定します
- **重要**：この段階でも2025は触りません。2025は最後に「最終ホールドアウト」として一度だけ開けます

### 設定案（設計意図に合わせて確認が必要）

現在の`train_end_date`の設定方法を確認します：

- **現在の実装**: `train_end_date`は固定で"2022-12-31"（`compare_lambda_penalties.py`の462-463行目）
- **`as_of_date=2024-12-31`の場合の設計**: 設計意図に合わせて以下のいずれかを選択

#### 案A：`train_end_date`を固定（2022-12-31）

- **`as_of_date`**: 2024-12-31
- **`train_end_date`**: 2022-12-31（固定）
- **24M test期間**: 2022年（2022-01-31 ～ 2022-12-30、12ヶ月分）
  - `train_max_rb = train_end_date - 24M = 2020-12-31`
  - `test_max_rb = as_of_date - 24M = 2022-12-31`
  - `test_rb = (train_max_rb, test_max_rb] = (2020-12-31, 2022-12-31]`

**メリット**：
- train期間が固定されるため、一貫性が保たれる
- 以前の最適化結果と比較しやすい

**デメリット**：
- train期間が短い（2018-01-01 ～ 2022-12-31）

#### 案B：`train_end_date`を`as_of_date`から計算

- **`as_of_date`**: 2024-12-31
- **`train_end_date`**: `as_of_date - 24M = 2022-12-31`（自動計算）
- **24M test期間**: 2022年（2022-01-31 ～ 2022-12-30、12ヶ月分）
  - `train_max_rb = train_end_date - 24M = 2020-12-31`
  - `test_max_rb = as_of_date - 24M = 2022-12-31`
  - `test_rb = (train_max_rb, test_max_rb] = (2020-12-31, 2022-12-31]`

**メリット**：
- `as_of_date`に追随するため、一貫性が保たれる
- より長いtrain期間を利用できる（2018-01-01 ～ 2022-12-31）

**デメリット**：
- 以前の最適化結果と直接比較しにくい（train期間が異なる）
- ただし、`as_of_date=2024`の場合、案Aと案Bで`train_end_date`は同じ（2022-12-31）になる

### 推奨案（`as_of_date=2024-12-31`の場合）

`as_of_date=2024-12-31`の場合、案Aと案Bで`train_end_date`は同じ（2022-12-31）になるため、**現在の実装（固定）のままで問題ありません**。

ただし、将来的に`as_of_date`がさらに上がる場合を考慮すると、**案B（`as_of_date`から計算）**を推奨します。

理由：
- `as_of_date`に追随するため、一貫性が保たれる
- より長いtrain期間を利用できる
- 最終ホールドアウト（2025）を使う際も、同様のロジックで一貫性が保たれる

## 実装上の考慮事項

### `compare_lambda_penalties.py`の修正

現在の`train_end_date`の設定方法を確認し、必要に応じて修正します。

### `optimize_longterm_main`の修正

`train_end_date`を`as_of_date`から計算する場合、`optimize_longterm_main`の内部ロジックも修正が必要かもしれません。

## 最終ホールドアウト（最後に1回だけ）

- λやパラメータが固まった後に、**2023年rebalance（→2025満了）**を評価
- ここで初めて2025を使う
- これが「温存」の設計意図と完全に一致します

## 次のステップ

1. **現在の`train_end_date`の設定方法を確認**
2. **`as_of_date=2024-12-31`での設定を決定**（案A or 案B）
3. **`compare_lambda_penalties.py`と`optimize_longterm_main`を修正**
4. **`as_of_date=2024-12-31`で24Mのλ比較を再実行**

