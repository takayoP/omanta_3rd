# 並列化の改善内容

## 改善前の問題

- **Optunaの試行**: 逐次実行（n_jobs=1）
- **各試行内のバックテスト**: 並列化済み
- **CPU利用率**: 低い（1試行ずつしか実行されない）

## 改善後の実装

### 2層の並列化

1. **Optunaの試行並列化**
   - CPU数の半分（最大8）で並列実行
   - 例: 32コア → 8試行を並列実行

2. **各試行内のバックテスト並列化**
   - 残りのCPUコアで並列実行
   - 例: 32コア、8試行並列 → 各試行内で4コア使用

### 理論上の最大並列度

- **32コアの場合**: 8試行 × 4コア = 32コア（100%活用）
- **16コアの場合**: 4試行 × 4コア = 16コア（100%活用）
- **8コアの場合**: 4試行 × 2コア = 8コア（100%活用）

## データベース書き込みの競合対策

- **SQLite WALモード**: 並列読み取りは可能
- **書き込み**: 各試行で独立したデータベース接続を使用
- **タイムアウト**: 30秒に設定（並列書き込み時の待機時間）

## 期待される効果

### 実行時間の短縮

- **改善前**: 20試行 × 各試行時間 = 総実行時間
- **改善後**: 20試行 ÷ 8並列 × 各試行時間 = 約1/8の実行時間（理論値）

### CPU利用率の向上

- **改善前**: 1コアのみ使用（各試行内の並列化のみ）
- **改善後**: 全コアを最大限活用（2層の並列化）

## 注意事項

1. **メモリ使用量**: 並列実行によりメモリ使用量が増加
2. **データベース競合**: 並列書き込み時の待機時間が発生する可能性
3. **最適化の収束**: 並列実行により最適化の収束が若干遅くなる可能性（TPEサンプラーの特性）

## 実行コマンド

```bash
python -m omanta_3rd.jobs.optimize_timeseries \
  --start 2021-01-01 \
  --end 2024-12-31 \
  --n-trials 20 \
  --study-name optimization_timeseries_20251230_phase1 \
  --no-progress-window
```

## 進行状況の確認

```bash
python check_optimization_progress.py
```



















